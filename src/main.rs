use clap::{
    builder::{PossibleValuesParser, TypedValueParser},
    Parser, ValueHint,
};
use clarity::vm::ClarityVersion;
use std::{
    fs,
    path::{Path, PathBuf},
    process,
};

mod analysis;
mod typescript;
mod utils;

#[derive(Parser)]
#[command(
    version,
    name = "Clarity Gen",
    about = "Generate typescript types from clarity contract"
)]
#[command(arg_required_else_help = true)]
struct Cli {
    /// Input clarity contract file
    #[arg(name="input", value_hint = ValueHint::FilePath)]
    input: PathBuf,

    /// Output typescript file (defaults to input with a .ts extension)
    #[arg(name="output", value_hint = ValueHint::FilePath)]
    output: Option<PathBuf>,

    /// Output contract type name
    #[arg(long, value_name = "name")]
    type_name: Option<String>,

    /// Clarity version
    #[arg(
        long = "clarity-version",
        value_name = "version",
        value_parser = PossibleValuesParser::new(["clarity1", "clarity2"]).map(|s| s.parse::<ClarityVersion>().expect("Unknown clarity version provided")),
    )]
    clarity_version: Option<ClarityVersion>,

    /// Path to trait requirement (defaults to .cache/requirements relative from src parent dir as generated by clarinet)
    #[arg(long, name="path", value_hint = ValueHint::DirPath)]
    trait_dir: Option<PathBuf>,
}

fn main() {
    let args = Cli::parse();

    // check file extension
    if args.input.extension().and_then(|ext| ext.to_str()) != Some("clar") {
        eprintln!("File must be a clarity contract with a .clar extension");
        process::exit(1)
    }

    let dest = args
        .output
        .unwrap_or_else(|| args.input.with_extension("ts"));
    let trait_dir = args.trait_dir.unwrap_or_else(|| {
        let mut dir = args
            .input
            .parent()
            .and_then(Path::parent)
            .map(Path::to_owned)
            .unwrap_or_default();
        dir.push(".cache/requirements");
        dir
    });
    let clarity_version = args.clarity_version.unwrap_or(ClarityVersion::Clarity2);
    let contract_name = args.type_name.unwrap_or_else(|| {
        args.input.file_stem().and_then(|s| s.to_str()).map(utils::to_pascal_case)
            .expect("Failed to get contract name! try passing the contract name with an option flag eg: `--type-name=Contract`")
    });

    // run contract analysis
    let contract_analysis = analysis::run(
        &contract_name,
        &args.input,
        Some(trait_dir),
        clarity_version,
    )
    .unwrap_or_else(|err| {
        if let Some(diagnostics) = err.diagnostics {
            for diagnostic in diagnostics {
                eprintln!("{diagnostic}");
            }
        }
        eprintln!("{}: {} at {:?}", err.message, err.name, err.path);
        process::exit(1)
    });

    // init typescript parser
    let mut ts_parser = typescript::Parser::new(contract_name);

    // add readonly and public functions
    for (name, fn_type) in contract_analysis.read_only_function_types {
        ts_parser.add_readonly_fn(name.to_string(), fn_type);
    }
    for (name, fn_type) in contract_analysis.public_function_types {
        ts_parser.add_public_fn(name.to_string(), fn_type);
    }

    // write typescript file
    let dest_contents = ts_parser.parse();
    match fs::write(&dest, dest_contents) {
        Ok(_) => println!("Created typescript file at {dest:?}"),
        Err(err) => {
            eprintln!("Failed to create typescript file: {}", err);
            process::exit(1)
        }
    };
}
