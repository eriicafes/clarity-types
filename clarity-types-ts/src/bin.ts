import { arg, createSingleProgram, flag } from "commandstruct"
import fs from "fs"
import process from "process"
import { parse } from "@clarity-types/core"

const prog = createSingleProgram("clarity-types")
    .version("0.1.0")
    .args({
        input: arg(),
        output: arg().optional()
    })
    .flags({
        typeName: flag("Output contract type name").optionalParam("string"),
        clarityVersion: flag("Clarity version (clarity1, clarity2)").optionalParam("string"),
        traitDir: flag("Path to trait requirement (defaults to .cache/requirements relative from input parent dir as generated by clarinet)").optionalParam("string"),
    })
    .action(({ args, flags }) => {
        // check file extension
        if (!args.input.endsWith(".clar")) {
            fail("File must be a clarity contract with a .clar extension")
        }

        // check clarity version
        let clarityVerion: "clarity1" | "clarity2" | undefined = undefined
        if (flags["clarity-version"]) {
            if (isClarityVersion(flags["clarity-version"])) clarityVerion = flags["clarity-version"]
            else fail("Unknown clarity version provided")
        }

        const dest = args.output || args.input.slice(0, -5) + ".ts"
        const result = parse(args.input, flags["trait-dir"], flags["type-name"], clarityVerion)

        try {
            fs.writeFileSync(dest, result)
            console.log(`Created typescript file at "${dest}"`)
        } catch (err) {
            fail(`Failed to create typescript file: ${err}`)
        }
    })

prog.run()

function isClarityVersion(str: string): str is "clarity1" | "clarity2" {
    return ["clarity1", "clarity2"].includes(str)
}

function fail(message: string): never {
    console.error(message)
    process.exit(1)
}
